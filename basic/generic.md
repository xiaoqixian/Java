---
author: lunar
date: Wed 26 Aug 2020 10:05:12 PM CST
---

### Java 泛型

很多人以为泛型只是为了让一个对象可以接纳多种类型，但这不是泛型的初衷，否则直接使用Object类就可以了。但是这样从取出类型时就必须使用强制类型转换。

#### 通配符T, E, ?, K V的区别

所谓通配符只是一个约定俗成的东西罢了，并不存在必须在哪个情况下使用哪个。

但是为了代码简洁易懂，我们按照以下规则使用通配符。

- ? 表示不确定的Java类型
- T 表示具体的Java类型
- K V表示键值对
- E 代表element

?和T区别是？是一个不确定类，？和T都表示不确定的类型 ，但如果是T的话，函数里面可以对T进行操作，比方 T car = getCar()，而不能用？ car = getCar()。

#### 泛型的接受限制

我们在使用泛型写代码时，可能只想泛型接受一部分类型的类，而不是通配所有类。

比如在一个比较方法里面，我们只愿意接受实现了Comparable接口的类。可以这样定义泛型
```java
public boolean Compare<T extends Comparable> {
    
}
```

`extends`既可以表示继承类，也可以表示实现某个接口。

如果需要实现多个接口，多个接口之间可以通过"&"分隔。**如果既要继承某个类，又要实现多个接口，那么该类必须位于第一个。**

如果需要使用多个泛型参数，可以通过逗号分隔。

#### 泛型代码和虚拟机

虚拟机没有泛型类型对象——所有对象都属于普通类。

**类型擦除**

无论何时定义了一个泛型类型，都自动提供了一个相应的原始类型（raw type）。原始类型的名字就是删去类型参数后的泛型类型名。擦除类型变量，并替换为限定类型(无限定的变量用Object)

**翻译泛型表达式**

类型擦除后，如果泛型变量没有限定的话，则转换为Object。对于返回泛型的表达式，编译器可以根据将要赋予的变量的类型，自动插入强制类型转换。

**翻译泛型方法**

类型擦除也会出现在泛型方法中，我们通常认为下面的泛型方法
`public static <T extends Comparable> T min(T[] a)`
是一个完整的方法族，而擦除类型后，只剩下一个方法
`public static Comparable min(Comparable[] a)`

有时类型擦除会与多态发生冲突，需要通过编译器生成一个桥方法。

#### 泛型类型的继承规则


