---
author: lunar
date: Thu 27 Aug 2020 11:54:50 AM CST
---

### Java 杂项

#### final, finally, finalize的区别

final: final修饰的类无法被继承，final修饰的方法无法被重写，final修饰的变量无法被修改。

finally: 在异常捕捉代码块中使用，无论是否发生异常，finally代码块中的代码都要执行。

finallize: Java允许使用finalize()方法在垃圾收集器将对象从内存清除出去之前做必要的清理工作。类似于C++中的析构方法。一般此方法由JVM调用，程序员不要调用。

#### ==和equals的区别和联系

"=="的使用情况如下：
1. 基本类型，比较值
2. 引用类型，比较地址
3. 不能比较没有父子关系的两个对象

equals()方法使用如下:
1. 系统类一般已经覆盖了equals()，比较的是内容
2. 用户自定义类如果没有覆盖equals()，则调用父类的equals()
3. 用户自定义类需要覆盖父类的equals()

#### java.sql.Date和 java.util.Date的联系和区别

1. java.sql.Date是java.util.Date的子类，是一个包装了毫秒值的瘦包装器，允许JDBC将毫秒值表示为SQL DATE值。
2. java.sql.Date和java.util.Date最大的区别在于java.sql.Date只记录日期，而没有具体这一天的时间。而java.util.Date则可以精确到毫秒。

#### 在继承的关系下，创建子类对象，会先执行父类的构造方法，再执行子类的构造方法

#### 为什么基本数据类型不能作为HashMap的键值，而只能是引用类型

在Java中是使用泛型来约束HashMap的key和value类型的；而泛型规定必须是Object类型的。基本数据类型不算是Object类型，因此不能作为键值，只能是引用类型。平时可以直接使用基本数据类型是因为Java进行自动封装的操作。

系统提供的引用数据类型中已经重写了HashCode()和equals()两个方法，所以能够保证Map中key值的唯一性；自定义的引用数据类型需要重写这两个方法来保证唯一性。

#### 接口和抽象类的区别

**相同点**

抽象类和接口都包含抽象方法，且子类必须实现所有抽象方法

抽象类和接口都不能实例化

**不同点**

接口只能定义全局静态长阿玲，不能定义变量，抽象类中可以定义常量和变量。

接口中所有的方法都是全局抽象方法，抽象类中可以有0个，1个或多个抽象方法

抽象类中可以有构造方法，但是不能用于实例化，而是在子类实例化时调用，用于抽象类的初始化工作。接口没有构造方法。

抽象类和接口在使用上的区别主要还是设计理念上的区别

抽象类实现了一种继承关系，子类和抽象类本质上还是一类事物。例如，所有的人都可以继承Person这个抽象类。抽象类与子类之间是"is-a"的关系。

接口则只是赋予这个类一部分特质的东西，告诉这个类必须做些什么。比如Student类必须上学，Doctor类必须治病等。这类不触及本质但是必须有的行为可以接口实现。接口和实现之间的关系可以认为是"has-a"的关系。



