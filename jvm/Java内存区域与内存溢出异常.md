---
author: lunar
date: Sun 13 Sep 2020 04:42:40 PM CST
---

## Java内存区域与内存溢出异常

### 运行时数据区域

JVM在运行时会将所管理的内存划分为多个区域, 包括:
1. 方法区(Method Area)
2. 虚拟机栈(VM stack)
3. 本地方法栈(Native Method Stack)
4. 堆(heap)
5. 程序计数器(Program Counter Register)

#### 程序计数器

用于指示下一步需要执行的字节码指令. 分支, 循环, 跳转, 异常处理等功能都需要这个计数器来完成.

每条线程都有一个自己的计数器, 位于"线程私有"的内存区域.

#### Java虚拟机栈

同样是线程私有的, 生命周期与线程相同. 描述的是Java方法执行的内存模型: 每个方法被执行时都会被创建一个栈帧(Stack Frame), 用于存储局部变量表, 操作栈, 动态链接, 方法出口等信息.

常说的栈内存就是位于Java虚拟机栈的局部变量表部分.

局部变量表部分存放了已知的各种基本数据类型, 对象引用和returnAddress类型.

64位长度的`long`和`double`类型占据两个局部变量空间(slot), 其余变量只占据一个slot. 局部变量表所需要的空间在编译期间就已经分配完毕, 当线程申请的栈空间超过允许的大小时, 就会抛出`StackOverflowError`异常.

#### 本地方法栈

本地方法栈为虚拟机使用到的本地方法服务. 什么叫本地方法呢?

本地方法是供Java虚拟机使用的但可能并不是Java语言实现的接口. 一些关乎操作系统底层的接口需要使用到C/C++语言进行实现, 比如多线程接口.

#### Java堆

**Java堆是被所有内存所共享的一块内存区域, 也是虚拟机所管理的最大的一块内存区域**.

所有的对象实例以及数组都要在堆上完成分配, 因此这一块也是垃圾回收的重点区域.

#### 方法区

方法区也是各个线程所共享的一块内存区域, 它用于**存储已被虚拟机加载的类信息, 常量, 静态变量, 即时编译器编译后的代码等数据.**

这个区域的内存回收主要是针对常量池的回收和对类型的卸载. 当方法区无法满足内存分配需求时, 将抛出`OutOfMemoryError`异常.

#### 运行时常量池

方法区的一部分, 用于存放编译期生成的各种字面量和字符引用, 这部分内容在类被加载后存放到运行时常量池里面.

#### 直接内存

内存对象分配在堆外的内存, 也叫直接内存. 

这样做一是解除了Java堆的内存限制, 二是减少了垃圾回收, 还可以提升IO速度.

Java的`ByteBuffer`类提供了分配直接内存的方法.
```java
import java.nio.ByteBuffer;

ByteBuffer bb = ByteBuffer.allocateDirect(128*1024*1204); 
```

### 对象访问

对于下面的这句代码:
```java
Object obj = new Object();
```

变量名`obj`将出现在本地变量表中, 作为一个reference类型数据出现. 而`new Object()`被分配在堆中, 形成一块存储了Object类型所有的实例数据值的结构化内存. 另外, 在Java堆中还必须包含能查找到此对象类型数据(如对象类型, 父类, 实现的接口, 方法等)的地址信息, 这些类型数据存储在方法区中.

Java对象的访问方式有两种: 使用句柄和直接指针.

- 使用句柄: reference中存储了对象的句柄地址, 而句柄中包含了对象实例数据和类型数据各自的具体地址信息.
- 直接指针: reference直接存储对象地址.

直接指针更快.


